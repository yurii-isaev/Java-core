package behavioral.iterator;

/**
 * Плюсы паттерна Iterator:
 * 1. Упрощение обхода коллекций:
 * Итератор позволяет обходить элементы коллекции без раскрытия ее внутренней реализации.
 * Это делает код более гибким и позволяет изменять структуру коллекции без влияния на код,
 * который использует итератор.
 * 2. Единообразный интерфейс:
 * Итератор предоставляет единый интерфейс для обхода различных типов коллекций.
 * Это позволяет клиентскому коду работать с разными коллекциями, не завися от их конкретной реализации.
 * 3. Поддержка одновременных итераций:
 * Итераторы позволяют выполнять одновременные итерации по одной и той же коллекции.
 * Это полезно, когда необходимо выполнять параллельные операции или сравнивать элементы из разных итераций.
 * 4. Возможность удаления элементов:
 * Итераторы обычно предоставляют метод remove(),
 * который позволяет удалять элементы из коллекции во время итерации.
 * Это удобно и безопасно, так как итератор следит за внутренним состоянием коллекции при удалении элементов.
 * <p>
 * Минусы паттерна Iterator:
 * 1. Ограниченная функциональность:
 * Итераторы предоставляют только базовые операции обхода и доступа к элементам коллекции.
 * Они не предоставляют возможности для более сложных операций,
 * таких как фильтрация, сортировка или преобразование элементов.
 * В таких случаях может потребоваться дополнительная логика или использование других паттернов.
 * 2. Накладные расходы:
 * Использование итератора может привести к небольшим накладным расходам в производительности,
 * особенно при работе с большими коллекциями.
 * Создание итератора и выполнение проверок на каждой итерации может иметь небольшое влияние на производительность.
 * 3. Необходимость обновления итератора:
 * Если структура коллекции изменяется во время итерации (элементы добавляются или удаляются),
 * итератор может стать недействительным.
 * В таком случае необходимо обновить итератор или пересоздать его, чтобы продолжить итерацию.
 * 4. Не подходит для всех ситуаций:
 * Паттерн Iterator не всегда является оптимальным решением для обхода коллекций.
 * В некоторых случаях более прямой доступ к элементам коллекции
 * или использование других паттернов может быть более эффективным или удобным.
 */

// Client code
public class Main {
   public static void main(String[] args) {
      MyCollection<String> collection = new MyCollection<>();
      collection.add("Element 1");
      collection.add("Element 2");
      collection.add("Element 3");

      Iterator<String> iterator = collection.createIterator();
      while (iterator.hasNext()) {
         String element = iterator.next();
         System.out.println(element);
      }

      // Removing an element using the iterator's remove() method
      iterator = collection.createIterator();
      while (iterator.hasNext()) {
         String element = iterator.next();
         if (element.equals("Element 2")) {
            iterator.remove();
         }
      }

      // Iterating again after removal
      iterator = collection.createIterator();
      while (iterator.hasNext()) {
         String element = iterator.next();
         System.out.println(element);
      }
   }
}
